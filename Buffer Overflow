Buffer Overflow Basics

A buffer is a data storage area inside a computer memory (stack or heap). It is intended to store a predefined amount of data. If more data is stuffed into it, it spills into adjacent memory. A buffer overflow basically occurs when a program writes data outside the bounds of allocated memory. They are generally exploited to overwrite values in memory to the advantage of the attacker. It is used to subvert the function of a privileged program so that the attacker can take control of it and if it is sufficiently privileged, then control the host.


Code Injection:
A string is provided as input to a program, which the program stores in a buffer. The string contains native CPU instructions for the platform being attacked.

Code Already There:
Code of interest already exists in the program. Attacker only needs to call it with desired arguments before jumping to it. eg. Attacker needs to acquire a shell, but code already in some library contains a call to the exec (arg). Attacker must only pass a pointer to the string "/bin/sh" and jump to the exec call.



1st gen exploits: Stack Smashing

Process memory is organized into 3 regions: Text, Data and Stack
Text/ Code section: Includes instructions and read only data. Modifications cause segmentation faults.
Data section: Initialized and uninitialized data, static and global variables.
Stack section: Used for implementing procedure abstraction.

Process memory structure
env/ argument section - top of memory (FFFF____)
stack
  |
  |
heap (dynamically allocated data)
data
code - bottom of memory (0000____)

If we look at a stack frame, stack usually grows towards lower memory addresses. 
Stack Frame:
Parameters            
Return Address        
Stack Frame Pointer   
Local Variables <- Stack pointer points here (this is the top of the stack, but lower memory address)

For example, we have this function:
void func (char *str) {
  char buf[126]; -> allocate local buffer (126 bytes reserved on stack)
  strcpy(buf,str); -> copy argument to local buffer
}

When this function is invoked, a new frame with local variables is pushed onto the stack:
Parameters
Return Address
Stack Frame Pointer
Local Variables


                      
