Malware & Reversing

Malware (Malicious Software)
There are 2 kinds of malware:
- Needs a host program (trap door, logic bomb, Trojan horse, viruses etc.)
- Independent (worms, bots etc.)

Viruses
Viruses "infect" a program by modifying it. They are self-copied into the program to spread.

Four stages:
1. Dormant Phase
2. Propagation Phase
3. Triggering Phase
4. Execution Phase

Virus Structure: First, go to "main" of virus program. Second, a special mark (infected or not). In main, find uninfected programs (infect and mark them), do something damaging to the system, now go to first line of the original program and appear to do the normal work. Also, avoid detection, by looking at the size of the program (compress/ decompress the original program).

Types of viruses:
- Parasitic virus (search and infect executable files)
- Memory resident virus (infect running programs)
- Boot Sector virus (spreads whenever the system is booted)
- Polymorphic virus (encrypt part of the virus program using randomly generated key)

Macro Virus
A macro is an executable program (eg. opening a file, starting an application) embedded in a word processing document (eg. MS Word). Common spreading technique: A virus macro is attached to a word document. Document is loaded and opened in the local system. When the macro executes, it copies itself to the global macro file. The global macro can be activated/ spread when new documents are opened. 

Antivirus
Prevention (limit contact to outside world)
Detection and identification 
Removal
4 generations of anti virus: simple scanners (use signatures of known viruses), heuristic scanners (checksums, encrypted hash), activity traps, full protection

Worm
It is code that replicates and propagates across the network (often carries a payload). It is usually spread via exploting flaws in open services. The 1st worm ever was the Morris worm (described below)

Worm detection and defense:
- Worm propagation modeling
- Automatic signature generation
- Detection: Honeypot based (eg. HoneyStat), Local information based (eg. DSC), Global information based (Kalman filter)
- Mitigation and Response

Interesting malware

Conficker.

Conficker, also known as Downup, Downadup, or Kido, is a notorious computer worm that first emerged in 2008. It quickly spread across networks, infecting computers and creating a massive botnet. The worm primarily targets computers running Microsoft Windows operating systems and takes advantage of vulnerabilities in the Windows OS to propagate and execute malicious activities. Here's a detailed explanation of how Conficker works and propagates:

**1. ** Initial Infection:
Conficker spreads through various methods, including exploiting a vulnerability in the Windows Server service (MS08-067) - a component of Microsoft Windows that provides file and print services to other computers on the network. The vulnerability allowed an attacker to send a specially crafted remote procedure call (RPC) request to the Windows Server service. The RPC is a protocol that one program can use to request a service from a program located on another computer in a network. In the case of MS08-067, the RPC request could trigger a buffer overflow condition in the Windows Server service. A buffer overflow occurs when a program writes more data to a block of memory, or buffer, than it can hold. This overflow can lead to unpredictable behavior and, in the case of a remote code execution vulnerability like MS08-067, potentially allow an attacker to execute arbitrary code on the target system. This vulnerability basically allows the worm to execute arbitrary code on remote computers without authentication. 

**2. ** Self-Replication:
Once a computer is infected, Conficker copies itself to the target system and assigns a random name. It also tries to disable security services and blocks access to security-related websites, making it difficult to download patches or security tools to remove the infection.

**3. ** Autorun and Network Propagation:
Conficker takes advantage of the Windows Autorun feature, which automatically runs programs when external devices like USB drives are connected to a computer. It places a copy of itself in the root folder of removable drives. When an infected USB drive is connected to another computer, the worm automatically executes and spreads to that system. It can also spread over network shares by copying itself to accessible network locations.

**4. ** P2P Communication:
Conficker includes a peer-to-peer (P2P) communication mechanism that allows infected computers to communicate with each other. This P2P network helps the worm update itself, download additional payloads, and receive commands from a remote controller. This communication method makes it harder to trace and control the botnet because infected computers can share information and updates without relying on a central server.

**5. ** Domain Generation Algorithm (DGA):
To receive updates and instructions, Conficker generates a large number of pseudo-random domain names using a sophisticated algorithm. Every day, it generates a new set of domain names. The authors of Conficker can register any of these domains and use them to control the infected machines, update the worm, or install additional malware. This technique makes it challenging for security researchers to predict or block the domains that the worm will attempt to contact.

**6. ** Evolution and Variants:
Conficker has several variants, each with improvements to evade detection and removal. These variants employ different encryption techniques, packers, and obfuscation methods to make it difficult for antivirus programs to identify and eliminate the worm.

**7. ** Payloads and Botnet Control:
While the primary purpose of Conficker is to create a massive botnet, it can also download and execute additional payloads. These payloads might include spyware, keyloggers, or other types of malware, allowing the attackers to steal sensitive information, launch distributed denial-of-service (DDoS) attacks, or perform other malicious activities.

In summary, Conficker spreads by exploiting Windows vulnerabilities, using Autorun and network propagation, establishing P2P communication, generating random domain names, evolving through variants, and executing various payloads. Its ability to continuously evolve and adapt makes it a significant challenge for security researchers and organizations to detect, remove, and mitigate its impact.


Morris worm.

 Here's a detailed breakdown of how the Morris Worm worked:

1. Initial Entry:
The Morris Worm primarily exploited vulnerabilities in Unix-based systems. It gained initial access through weak or easily guessable passwords. The worm used a dictionary attack, attempting to log into user accounts using a predefined list of common passwords. Once it found a weak password, it gained unauthorized access to the system.

2. Remote Execution:
Upon gaining access, the worm exploited various vulnerabilities to execute its code remotely. It took advantage of vulnerabilities in network services like Sendmail, Finger, rsh (remote shell), and rexec (remote execution) to run arbitrary code on the compromised system. These services had security flaws that the worm could exploit to inject its payload.

3. Payload Execution:
The worm's payload was executed on the compromised system. This payload included code to scan for other vulnerable systems and propagate the worm further. The worm didn't just execute once; it had a mechanism to spawn multiple copies of itself, which significantly accelerated its propagation speed.

4. Scanning and Propagation:
The worm used a variety of techniques to find and infect other vulnerable systems within the same network:

IP Address Scanning: The Morris Worm scanned IP addresses in its local network to find other Unix systems.

Subnet Scanning: It performed subnet scans, searching for hosts within the same network range.

Spoofing: The worm could forge the source address in its network packets, making it difficult to trace the origin of the attack.

Exploiting Vulnerabilities: When the worm found another vulnerable system, it used the same techniques as the initial infection (password cracking and exploiting vulnerabilities) to gain access and execute its payload on the new target.

5. Self-Replication and Multiple Execution:
One of the most significant features of the Morris Worm was its ability to replicate and execute multiple times on the same system. This led to a rapid increase in the number of worm processes running on an infected host, consuming system resources and making it difficult to manually remove the worm.

6. Detection Evasion:
The worm attempted to evade detection by hiding its presence. It used techniques such as polymorphic encryption, which involves changing the worm's code slightly each time it spread, making it harder to identify using signature-based detection methods.

7. Impact and Remediation:
The rapid and uncontrolled spread of the Morris Worm led to system slowdowns and outages across the early internet. To remove the worm, security researchers and system administrators had to collaborate closely. They employed network analysis tools to identify infected systems, isolated them to prevent further spread, and applied patches and updates to vulnerable software. Additionally, user awareness and education campaigns were launched to prevent similar incidents in the future.

Zeus malware.

Stuxnet.

Stuxnet is a highly sophisticated and infamous computer worm that was discovered in 2010. It was designed to target supervisory control and data acquisition (SCADA) systems, specifically those used in Iran's nuclear program. Stuxnet is widely believed to be a joint creation of American and Israeli intelligence agencies. For security researchers, understanding how Stuxnet works provides valuable insights into advanced persistent threats and the techniques used in state-sponsored cyber-espionage. Here's a detailed breakdown of how Stuxnet operates:

1. Propagation:
Stuxnet primarily spreads through infected USB drives. When a USB drive containing the worm is inserted into a system running Microsoft Windows, it takes advantage of several zero-day vulnerabilities and spreads via the autorun feature and through network shares if available.

2. Infection and Persistence:

1. Rootkit Capabilities:
A rootkit is a type of malicious software that is designed to hide its presence or the presence of other malware on a computer system. Rootkits operate at a deep level within the operating system, often at the kernel level or by intercepting system calls, allowing them to conceal their existence and activities from both the operating system and traditional security software.

How Stuxnet Uses Rootkit Techniques:

Kernel Level Access: Stuxnet gains kernel-level access, which means it can manipulate the core components of the operating system. By doing so, it can intercept and modify system calls, ensuring that its malicious activities go unnoticed.

File and Process Hiding: Stuxnet can hide its files, processes, and registry entries from the view of the operating system and any security software. This means that even if an antivirus program scans the system, the Stuxnet-related files and processes remain invisible.

Persistence: Rootkits like Stuxnet often ensure their persistence on the infected system. They modify system files or configurations to automatically start with the operating system, ensuring that the malicious code runs every time the computer boots up.

Evasion of Detection Tools: Rootkits are notoriously difficult to detect because they actively work to evade detection. They may tamper with the memory space of antivirus and security software, making it appear as though the system is clean when it's actually compromised.

Privilege Escalation: Some rootkits exploit vulnerabilities to escalate their privileges. By gaining higher levels of access, they can perform more malicious actions, making it even more challenging for security software to identify and remove them.

2. Exploiting Vulnerabilities, Including the LNK Vulnerability:
Exploiting vulnerabilities is a common method used by malware to infiltrate computer systems. Vulnerabilities are flaws or weaknesses in software code that can be exploited to perform unauthorized actions or gain access to sensitive data.

Exploiting the LNK Vulnerability:

The LNK Vulnerability: One of the notable vulnerabilities exploited by Stuxnet was the LNK (shortcut) vulnerability in Windows. LNK files are shortcuts used to launch applications quickly. Stuxnet utilized a flaw in how Windows handled LNK files, allowing it to execute arbitrary code when a user opened a folder containing a malicious LNK file.

Execution of Arbitrary Code: Stuxnet crafted LNK files that contained malicious code. When a user opened a folder containing one of these specially crafted LNK files, the malware exploited the vulnerability, executing its code on the system. This provided Stuxnet with an entry point to infect the system and start its malicious activities.

Delivery Mechanism: Stuxnet commonly used USB drives as a delivery mechanism for spreading its malicious LNK files. When an infected USB drive was plugged into a Windows system, the LNK files would execute, allowing Stuxnet to infiltrate the system.

3. Target Identification:
Stuxnet is designed to target specific SCADA systems. It contains code to identify a particular industrial control system configuration using specific Siemens Step7 project files. If the targeted system is not found, Stuxnet remains dormant, reducing the chances of detection.

4. Payload Delivery:
Stuxnet carries two main payloads: one to manipulate frequency converter drives and another to manipulate PLCs (Programmable Logic Controllers). These components work together to take control of the targeted industrial processes.

Manipulating Frequency Converter Drives: Stuxnet modifies code on frequency converter drives used in uranium enrichment centrifuges. It changes the operating frequency of these drives subtly, causing physical damage to the centrifuges over time. This sabotage tactic aimed to disrupt Iran's nuclear enrichment efforts.

Manipulating PLCs: Stuxnet uses rogue code to take control of specific models of Siemens PLCs. It then sends malicious commands to manipulate the operation of connected industrial equipment. This allows Stuxnet to take over the SCADA systems and potentially cause severe physical damage to the industrial processes controlled by these systems.

5. Stealth and Evasion:
Stuxnet uses various evasion techniques to avoid detection and analysis:

Code Signing Certificates: It uses stolen digital certificates to make its components appear legitimate, allowing it to evade security checks.

Polymorphic Code: Stuxnet constantly modifies its code to create multiple, slightly different versions of itself, making it difficult to detect using traditional signature-based antivirus software.

Network Propagation: Stuxnet actively seeks other vulnerable systems on the network and infects them, allowing it to spread laterally within the target environment.

6. Command and Control (C&C) Servers:
Stuxnet communicates with remote servers controlled by the attackers to receive updated instructions and potentially exfiltrate data. These C&C servers are used for maintaining control over the infected systems and for collecting information about the compromised networks.

Wannacry.
CookieMiner.
Sunburst.
Malware features

Various methods of getting remote code execution.
Domain-flux.
Fast-Flux.
Covert C2 channels.
Evasion techniques (e.g. anti-sandbox).
Process hollowing.
Mutexes.
Multi-vector and polymorphic attacks.
RAT (remote access trojan) features.
Decompiling/ reversing

Obfuscation of code, unique strings (you can use for identifying code).
IdaPro, Ghidra.
Static / dynamic analysis

Describe the differences.
Virus total.
Reverse.it.
Hybrid Analysis.
