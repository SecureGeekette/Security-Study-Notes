Malware & Reversing
Interesting malware

Conficker.

Conficker, also known as Downup, Downadup, or Kido, is a notorious computer worm that first emerged in 2008. It quickly spread across networks, infecting computers and creating a massive botnet. The worm primarily targets computers running Microsoft Windows operating systems and takes advantage of vulnerabilities in the Windows OS to propagate and execute malicious activities. Here's a detailed explanation of how Conficker works and propagates:

**1. ** Initial Infection:
Conficker spreads through various methods, including exploiting a vulnerability in the Windows Server service (MS08-067) - a component of Microsoft Windows that provides file and print services to other computers on the network. The vulnerability allowed an attacker to send a specially crafted remote procedure call (RPC) request to the Windows Server service. The RPC is a protocol that one program can use to request a service from a program located on another computer in a network. In the case of MS08-067, the RPC request could trigger a buffer overflow condition in the Windows Server service. A buffer overflow occurs when a program writes more data to a block of memory, or buffer, than it can hold. This overflow can lead to unpredictable behavior and, in the case of a remote code execution vulnerability like MS08-067, potentially allow an attacker to execute arbitrary code on the target system. This vulnerability basically allows the worm to execute arbitrary code on remote computers without authentication. 

**2. ** Self-Replication:
Once a computer is infected, Conficker copies itself to the target system and assigns a random name. It also tries to disable security services and blocks access to security-related websites, making it difficult to download patches or security tools to remove the infection.

**3. ** Autorun and Network Propagation:
Conficker takes advantage of the Windows Autorun feature, which automatically runs programs when external devices like USB drives are connected to a computer. It places a copy of itself in the root folder of removable drives. When an infected USB drive is connected to another computer, the worm automatically executes and spreads to that system. It can also spread over network shares by copying itself to accessible network locations.

**4. ** P2P Communication:
Conficker includes a peer-to-peer (P2P) communication mechanism that allows infected computers to communicate with each other. This P2P network helps the worm update itself, download additional payloads, and receive commands from a remote controller. This communication method makes it harder to trace and control the botnet because infected computers can share information and updates without relying on a central server.

**5. ** Domain Generation Algorithm (DGA):
To receive updates and instructions, Conficker generates a large number of pseudo-random domain names using a sophisticated algorithm. Every day, it generates a new set of domain names. The authors of Conficker can register any of these domains and use them to control the infected machines, update the worm, or install additional malware. This technique makes it challenging for security researchers to predict or block the domains that the worm will attempt to contact.

**6. ** Evolution and Variants:
Conficker has several variants, each with improvements to evade detection and removal. These variants employ different encryption techniques, packers, and obfuscation methods to make it difficult for antivirus programs to identify and eliminate the worm.

**7. ** Payloads and Botnet Control:
While the primary purpose of Conficker is to create a massive botnet, it can also download and execute additional payloads. These payloads might include spyware, keyloggers, or other types of malware, allowing the attackers to steal sensitive information, launch distributed denial-of-service (DDoS) attacks, or perform other malicious activities.

In summary, Conficker spreads by exploiting Windows vulnerabilities, using Autorun and network propagation, establishing P2P communication, generating random domain names, evolving through variants, and executing various payloads. Its ability to continuously evolve and adapt makes it a significant challenge for security researchers and organizations to detect, remove, and mitigate its impact.


Morris worm.

 Here's a detailed breakdown of how the Morris Worm worked:

1. Initial Entry:
The Morris Worm primarily exploited vulnerabilities in Unix-based systems. It gained initial access through weak or easily guessable passwords. The worm used a dictionary attack, attempting to log into user accounts using a predefined list of common passwords. Once it found a weak password, it gained unauthorized access to the system.

2. Remote Execution:
Upon gaining access, the worm exploited various vulnerabilities to execute its code remotely. It took advantage of vulnerabilities in network services like Sendmail, Finger, rsh (remote shell), and rexec (remote execution) to run arbitrary code on the compromised system. These services had security flaws that the worm could exploit to inject its payload.

3. Payload Execution:
The worm's payload was executed on the compromised system. This payload included code to scan for other vulnerable systems and propagate the worm further. The worm didn't just execute once; it had a mechanism to spawn multiple copies of itself, which significantly accelerated its propagation speed.

4. Scanning and Propagation:
The worm used a variety of techniques to find and infect other vulnerable systems within the same network:

IP Address Scanning: The Morris Worm scanned IP addresses in its local network to find other Unix systems.

Subnet Scanning: It performed subnet scans, searching for hosts within the same network range.

Spoofing: The worm could forge the source address in its network packets, making it difficult to trace the origin of the attack.

Exploiting Vulnerabilities: When the worm found another vulnerable system, it used the same techniques as the initial infection (password cracking and exploiting vulnerabilities) to gain access and execute its payload on the new target.

5. Self-Replication and Multiple Execution:
One of the most significant features of the Morris Worm was its ability to replicate and execute multiple times on the same system. This led to a rapid increase in the number of worm processes running on an infected host, consuming system resources and making it difficult to manually remove the worm.

6. Detection Evasion:
The worm attempted to evade detection by hiding its presence. It used techniques such as polymorphic encryption, which involves changing the worm's code slightly each time it spread, making it harder to identify using signature-based detection methods.

7. Impact and Remediation:
The rapid and uncontrolled spread of the Morris Worm led to system slowdowns and outages across the early internet. To remove the worm, security researchers and system administrators had to collaborate closely. They employed network analysis tools to identify infected systems, isolated them to prevent further spread, and applied patches and updates to vulnerable software. Additionally, user awareness and education campaigns were launched to prevent similar incidents in the future.
Zeus malware.
Stuxnet.
Wannacry.
CookieMiner.
Sunburst.
Malware features

Various methods of getting remote code execution.
Domain-flux.
Fast-Flux.
Covert C2 channels.
Evasion techniques (e.g. anti-sandbox).
Process hollowing.
Mutexes.
Multi-vector and polymorphic attacks.
RAT (remote access trojan) features.
Decompiling/ reversing

Obfuscation of code, unique strings (you can use for identifying code).
IdaPro, Ghidra.
Static / dynamic analysis

Describe the differences.
Virus total.
Reverse.it.
Hybrid Analysis.
