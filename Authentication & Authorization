Authentication is used to verify that you are who you say you are i.e. validate a user's identity.
User authentication is the priority while responding to a request made by a software application.



How do cookies work?

Cookies are small pieces of data sent from a web server and stored in a user's web browser while the user is browsing a website. They are essential for many web applications because they enable the server to remember stateful information as users navigate different pages or revisit the website. Here's how they function:

Identification: When you visit a website, the server sends a cookie containing a unique identifier to your browser.

Storage: The browser stores this cookie on your device. Subsequently, every time you make a request to the same website, the cookie is sent back to the server, allowing it to recognize you.

Session Management: Cookies help manage user sessions, store login credentials, remember items in a shopping cart, and personalize user experiences.

Set-Cookie: user_id=12345; expires=Wed, 09 Jun 2023 10:18:14 GMT; path=/; domain=.example.com; Secure; HttpOnly

Risks:
1. Session Hijacking: If a cookie is intercepted, an attacker can impersonate a user, leading to unauthorized access to sensitive data or actions on the website.
2. Cross-Site Scripting (XSS): Malicious scripts injected into a web page can steal cookies, enabling attackers to hijack user sessions.
3. Cross-Site Request Forgery (CSRF): Attackers trick users into performing actions on a website without their consent by utilizing their active sessions, often through manipulated URLs containing cookies.
4. Data Privacy Concerns: Cookies can store personal information, raising privacy issues, especially when third-party cookies track users across various websites without their consent.
5. Cookie Theft: Malware or malicious scripts can steal cookies from users' browsers, leading to security breaches or identity theft.

Let's discuss some commonly used authentication protocols:

Kerberos (Used in Active Directory):

Kerberos is a network authentication protocol developed by MIT. This is primarily used by a client to prove it's identity to a server over an insecure network connection using symmetric (or secret key cryptography).

High Level process is as follows:
1. The client/ user requests an authentication ticket called TGT (ticket granting ticket).
2. The Windows Server/ Domain Controller has a KDC (key Distribution Center) which verifies the credentials (via the authentication server) and sends back an encrypted TGT (via a Ticket granting server).
3. The client sends the current TGT to the TGS with the name of the resource the client wants to access (Request Ticket).
4. The TGS sends a valid session key for the service to the client.
5. The client stores the TGT and when it expires, the local session manager will request another TGT (from the Windows Server).
6. The client then requests the service using the valid session key
7. Server authentication occurs.

Details:

Client Server Authentication:
1. The client sends a cleartext message of the user ID to the authentication server requesting services on behalf of the user. (Neither the secret key nor the password is sent at this point).
2. The authentication server checks if the client/ requested user ID is in its database. If it is, the authentication server generates the secret key by hashing the password of the user found in the database (eg. Active Directory in Windows server) and sends back the following messages:
- TGS session key encrypted using the secret key of the client/user
- Ticket Granting Ticket which includes the client ID, client network addeess, ticket validity period and the TGS session key. All these parameters are encrypted using the secret key of the TGS.
3. Once the client receives the messages, it tries to decrypt the session key using the password entered by the user. If the user entered password does not match the password in the database, they will not be able to retrieve the session key.

Client Service Authorization:
1. The client sends the encrypted TGT received from the server and the ID of the client. They also send the client ID and timestamp encrypted using the TGS session key.
2. TGS retrieves the TGT since it has access to the TGS secret key. This gives it access to the session key. The server then compares the client ID from the TGT to the message received and if they match, the server sends the following:
- Client to Server ticket which includes client ID, client network address, validity period and the session key encrypted using the service's secret key.
- Client/ Server session key encrypted using the TGS session key.

Client Service Request:
- The client sends the client to server ticket encrypted using the service's secret key. The client also sends a new authenticator which includes the client ID, timestamp and is encrypted using the client/ server session key.
- The service server decrypt's the client to server ticket and obtains the session key which it uses to decrypt the new authenticator message, If all the details match, the server encrypts the timestamp.
- The client decrypts the timestamp, if it is correct the client can trust the server and start issuing service requests to the client.
- The server then provides the requested services to the client.


SAML (Security Assertion Markup Language)

Federated Login: This enables users to use a single authentication ticket/ token to obtain access across all networks of the different IT systems.

SAML is an open federation standard that allows an Identity Provider (IdP) to authenticate users and then pass an authentication token to another application known as Service Provider (SP). With SAML, you can enable SSO.

Identity Provider                                   Browser                                             Service Provider

                                                       ---->     User attempts to access a protected resource
                                                    Redirect the browser to the IdP for authentication with a SAML request <---- 
Access the IdP SSO endpoint   <------
Present a login form to the user ------>
Authenticate to the IdP with existing credentials <------
Validate credentials and generate SAML response ------>
                                                Post the SAML response (authentication and attribute statements) to the SP ---->
                                                                              Check authenticity of the response and extract details
                                                    Set Cookie  <--------
                                                Access as authenticated user


What is a SAML assertion?

A SAML assertion is a XML document that the IdP sends to the SP containing the user authorization status.
Authentication assertions help verify the identification of a user and provide the time a user logs in and which method of authentication is used (for eg. MFA, password, kerberos etc.)
Authorization assertion states if a user is authorized to use a service or if the IdP has denied the request (due a authentication failure or due to lack of rights to a service.


OAuth (built on OAuth Open ID Connect - Open Authorization)

OAuth is an authorization protocol that allows users to grant third-party applications limited access to their resources without sharing their credentials (like username and password) directly with the application. It works by enabling resource owners to delegate access to their resources (stored on one server) to a client aopplication (accessing the resources on behalf of the resource owner)

Here's how it works:

1. Client Registration: The client application (application that needs access to the user's resources) registers with the OAuth provider (authorization server). During registration, the client is issued a client ID and client secret. These credentials are used to authenticate the client with the authorization server. 

2. Authorization Request: When the user (resource owner) want to grant the client application access to their resources, the client initiates the OAuth process by redirecting the user to the authorization server. The client includes its client ID and specifies the scope of the access it needs (eg. read, write etc.) in the authorization request.

3. User authorization: The authorization server authenticates the user and presents them with a consent screen, informing them about the requested permissions the client making the request (user can grant or deny the request)

4. Authorization grant: If the user grants permissioon, the authorization server issues an authorization code to the client. The code is sent to the client's redirect URI.

5. Access Token Request: The client sends a request to the authorization server to exchange the authorization code for an access token. This token includes its client ID, client secret and authorization code.

6. Access Token Issuance: The authorization server validates the client's credentials and the authorization code. If everything is valid, the authorization server issues an access token to the client. 

7. Accessing Protected resources: The client includes the access token in the request to the resource server when accessing the protected resources. The resource server validates the access token and if valid and authorized for requested scope, the requested resource is served. 

8. Token Expiration and refresh: Access tokens have a limited lifespan. If the client needs prolonged access, it can use a refresh token to obtain a new access token without user interaction.



Authentication and Authorization between a client and a server

Static websites are easy to scale. You can cache the heck out of them and you don’t have state to propagate between the various servers that deliver this content to end-users.

Unfortunately, most web applications need to carry some state in order to offer a personalized experience to users. If users can log into your site, then you need to keep sessions for them. The typical way that this is done is by setting a cookie with a random session identifier and storing session details on the server under this identifier.

Scaling a stateful service
Now, if you want to scale that service, you essentially have three options:

replicate that session data across all of the web servers,
use a central store that each web server connects to, or
ensure that a given user always hits the same web server
These all have downsides:

Replication has a performance cost and increases complexity.
A central store will limit scaling and increase latency.
Confining users to a specific server leads to problems when that
server needs to come down.
However, if you flip the problem around, you can find a fourth option: storing the session data on the client.

Client-side sessions
Pushing the session data to the browser has some obvious advantages:

the data is always available, regardless of which machine is serving a user
there is no state to manage on servers
nothing needs to be replicated between the web servers
new web servers can be added instantly
There is one key problem though: you cannot trust the client not to tamper with the session data.

For example, if you store the user ID for the user’s account in a cookie, it would be easy for that user to change that ID and then gain access to someone else’s account.

While this sounds like a deal breaker, there is a clever solution to work around this trust problem: store the session data in a tamper-proof package. That way, there is no need to trust that the user hasn’t modified the session data. It can be verified by the server.

What that means in practice is that you encrypt and sign the cookie using a server key to keep users from reading or modifying the session data. This is what client-sessions (a Node.js library) does.

Immediate revocation of Persona sessions
One of the main downsides of client-side sessions as compared to server-side ones is that the server no longer has the ability to destroy sessions.

Using a server-side scheme, it’s enough to delete the session data that’s stored on the server because any cookies that remain on clients will now point to a non-existent session. With a client-side scheme though, the session data is not on the server, so the server cannot be sure that it has been deleted on every client. In other words, we can’t easily synchronize the server state (user logged out) with the state that’s stored on the client (user logged in).

To compensate for this limitation, client-sessions adds an expiry to the cookies. Before unpacking the session data stored in the encrypted cookie, the server will check that it hasn’t expired. If it has, it will simply refuse to honour it and consider the user as logged out.

While the expiry scheme works fine in most applications (especially when it’s set to a relatively low value), in the case of Persona, we needed a way for users to immediately revoke their sessions as soon as they learn that they password has been compromised.

This meant keeping a little bit of state on the backend. The way we made this instant revocation possible was by adding a new token in the user table as well as in the session cookie.

Every API call that looks at the cookie now also reads the current token value from the database and compares it with the token from the cookie. Unless they are the same, an error is returned and the user is logged out.

The downside of this solution, of course, is the extra database read for each API call, but fortunately we already read from the user table in most of these calls, so the new token can be pulled in at the same time.
