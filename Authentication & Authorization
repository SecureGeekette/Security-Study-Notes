Authentication is used to verify that you are who you say you are i.e. validate a user's identity.
User authentication is the priority while responding to a request made by a software application.



How do cookies work?

Cookies are small pieces of data sent from a web server and stored in a user's web browser while the user is browsing a website. They are essential for many web applications because they enable the server to remember stateful information as users navigate different pages or revisit the website. Here's how they function:

Identification: When you visit a website, the server sends a cookie containing a unique identifier to your browser.

Storage: The browser stores this cookie on your device. Subsequently, every time you make a request to the same website, the cookie is sent back to the server, allowing it to recognize you.

Session Management: Cookies help manage user sessions, store login credentials, remember items in a shopping cart, and personalize user experiences.

Set-Cookie: user_id=12345; expires=Wed, 09 Jun 2023 10:18:14 GMT; path=/; domain=.example.com; Secure; HttpOnly

Risks:
Session Hijacking: If a cookie is intercepted, an attacker can impersonate a user, leading to unauthorized access to sensitive data or actions on the website.

Cross-Site Scripting (XSS): Malicious scripts injected into a web page can steal cookies, enabling attackers to hijack user sessions.

Cross-Site Request Forgery (CSRF): Attackers trick users into performing actions on a website without their consent by utilizing their active sessions, often through manipulated URLs containing cookies.

Data Privacy Concerns: Cookies can store personal information, raising privacy issues, especially when third-party cookies track users across various websites without their consent.

Cookie Theft: Malware or malicious scripts can steal cookies from users' browsers, leading to security breaches or identity theft.

Let's discuss some commonly used authentication protocols:

Kerberos (Used in Active Directory):

Kerberos is a network authentication protocol developed by MIT. This is primarily used by a client to prove it's identity to a server over an insecure network connection using symmetric (or secret key cryptography).

High Level process is as follows:
1. The client/ user requests an authentication ticket called TGT (ticket granting ticket).
2. The Windows Server/ Domain Controller has a KDC (key Distribution Center) which verifies the credentials (via the authentication server) and sends back an encrypted TGT (via a Ticket granting server).
3. The client sends the current TGT to the TGS with the name of the resource the client wants to access (Request Ticket).
4. The TGS sends a valid session key for the service to the client.
5. The client stores the TGT and when it expires, the local session manager will request another TGT (from the Windows Server).
6. The client then requests the service using the valid session key
7. Server authentication occurs.

Details:

Client Server Authentication:
1. The client sends a cleartext message of the user ID to the authentication server requesting services on behalf of the user. (Neither the secret key nor the password is sent at this point).
2. The authentication server checks if the client/ requested user ID is in its database. If it is, the authentication server generates the secret key by hashing the password of the user found in the database (eg. Active Directory in Windows server) and sends back the following messages:
- TGS session key encrypted using the secret key of the client/user
- Ticket Granting Ticket which includes the client ID, client network addeess, ticket validity period and the TGS session key. All these parameters are encrypted using the secret key of the TGS.
3. Once the client receives the messages, it tries to decrypt the session key using the password entered by the user. If the user entered password does not match the password in the database, they will not be able to retrieve the session key.

Client Service Authorization:
1. The client sends the encrypted TGT received from the server and the ID of the client. They also send the client ID and timestamp encrypted using the TGS session key.
2. TGS retrieves the TGT since it has access to the TGS secret key. This gives it access to the session key. The server then compares the client ID from the TGT to the message received and if they match, the server sends the following:
- Client to Server ticket which includes client ID, client network address, validity period and the session key encrypted using the service's secret key.
- Client/ Server session key encrypted using the TGS session key.

Client Service Request:
- The client sends the client to server ticket encrypted using the service's secret key. The client also sends a new authenticator which includes the client ID, timestamp and is encrypted using the client/ server session key.
- The service server decrypt's the client to server ticket and obtains the session key which it uses to decrypt the new authenticator message, If all the details match, the server encrypts the timestamp.
- The client decrypts the timestamp, if it is correct the client can trust the server and start issuing service requests to the client.
- The server then provides the requested services to the client.


SAML (Security Assertion Markup Language)

Federated Login: This enables users to use a single authentication ticket/ token to obtain access across all networks of the different IT systems.

SAML is an open federation standard that allows an Identity Provider (IdP) to authenticate users and then pass an authentication token to another application known as Service Provider (SP). With SAML, you can enable SSO.

Identity Provider                                   Browser                                             Service Provider

                                                       ---->     User attempts to access a protected resource
                                                    Redirect the browser to the IdP for authentication with a SAML request <---- 
Access the IdP SSO endpoint   <------
Present a login form to the user ------>
Authenticate to the IdP with existing credentials <------
Validate credentials and generate SAML response ------>
                                                Post the SAML response (authentication and attribute statements) to the SP ---->
                                                                              Check authenticity of the response and extract details
                                                    Set Cookie  <--------
                                                Access as authenticated user


What is a SAML assertion?

A SAML assertion is a XML document that the IdP sends to the SP containing the user authorization status.
Authentication assertions help verify the identification of a user and provide the time a user logs in and which method of authentication is used (for eg. MFA, password, kerberos etc.)
Authorization assertion states if a user is authorized to use a service or if the IdP has denied the request (due a authentication failure or due to lack of rights to a service.


OAuth (built on OAuth Open ID Connect - Open Authorization)

OAuth is an authorization protocol that allows users to grant third-party applications limited access to their resources without sharing their credentials (like username and password) directly with the application. It works by enabling resource owners to delegate access to their resources (stored on one server) to a client aopplication (accessing the resources on behalf of the resource owner)

Here's how it works:

1. Client Registration: The client application (application that needs access to the user's resources) registers with the OAuth provider (authorization server). During registration, the client is issued a client ID and client secret. These credentials are used to authenticate the client with the authorization server. 

2. Authorization Request: When the user (resource owner) want to grant the client application access to their resources, the client initiates the OAuth process by redirecting the user to the authorization server. The client includes its client ID and specifies the scope of the access it needs (eg. read, write etc.) in the authorization request.

3. User authorization: The authorization server authenticates the user and presents them with a consent screen, informing them about the requested permissions the client making the request (user can grant or deny the request)

4. Authorization grant: If the user grants permissioon, the authorization server issues an authorization code to the client. The code is sent to the client's redirect URI.

5. Access Token Request: The client sends a request to the authorization server to exchange the authorization code for an access token. This token includes its client ID, client secret and authorization code.

6. Access Token Issuance: The authorization server validates the client's credentials and the authorization code. If everything is valid, the authorization server issues an access token to the client. 

7. Accessing Protected resources: The client includes the access token in the request to the resource server when accessing the protected resources. The resource server validates the access token and if valid and authorized for requested scope, the requested resource is served. 

8. Token Expiration and refresh: Access tokens have a limited lifespan. If the client needs prolonged access, it can use a refresh token to obtain a new access token without user interaction.
